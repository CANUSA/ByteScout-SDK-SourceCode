<?php
/**
 * PDFExtractorApi
 * PHP version 5
 *
 * @category Class
 * @package  Bytescout\Client
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */
/**
 *  Copyright 2016 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program. 
 * https://github.com/swagger-api/swagger-codegen 
 * Do not edit the class manually.
 */

namespace Bytescout\Client\Api;

use \Bytescout\Client\Configuration;
use \Bytescout\Client\ApiClient;
use \Bytescout\Client\ApiException;
use \Bytescout\Client\ObjectSerializer;

/**
 * PDFExtractorApi Class Doc Comment
 *
 * @category Class
 * @package  Bytescout\Client
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class PDFExtractorApi
{

    /**
     * API Client
     * @var \Bytescout\Client\ApiClient instance of the ApiClient
     */
    protected $apiClient;
  
    /**
     * Constructor
     * @param \Bytescout\Client\ApiClient|null $apiClient The api client to use
     */
    function __construct($apiClient = null)
    {
        if ($apiClient == null) {
            $apiClient = new ApiClient();
            $apiClient->getConfig()->setHost('https://bytescout.io');
        }
  
        $this->apiClient = $apiClient;
    }
  
    /**
     * Get API client
     * @return \Bytescout\Client\ApiClient get the API client
     */
    public function getApiClient()
    {
        return $this->apiClient;
    }
  
    /**
     * Set the API client
     * @param \Bytescout\Client\ApiClient $apiClient set the API client
     * @return PDFExtractorApi
     */
    public function setApiClient(ApiClient $apiClient)
    {
        $this->apiClient = $apiClient;
        return $this;
    }
  
    
    /**
     * pDFExtractorCSVExtractorFile
     *
     * Convert PDF document to CSV
     *
     * @param \Bytescout\Client\Model\CSVExtractorRequestVm $data  (required)
     * @param string $apikey User&#39;s ApiKey (optional)
     * @return string
     * @throws \Bytescout\Client\ApiException on non-2xx response
     */
    public function pDFExtractorCSVExtractorFile($data, $apikey = null)
    {
        list($response, $statusCode, $httpHeader) = $this->pDFExtractorCSVExtractorFileWithHttpInfo ($data, $apikey);
        return $response; 
    }


    /**
     * pDFExtractorCSVExtractorFileWithHttpInfo
     *
     * Convert PDF document to CSV
     *
     * @param \Bytescout\Client\Model\CSVExtractorRequestVm $data  (required)
     * @param string $apikey User&#39;s ApiKey (optional)
     * @return Array of string, HTTP status code, HTTP response headers (array of strings)
     * @throws \Bytescout\Client\ApiException on non-2xx response
     */
    public function pDFExtractorCSVExtractorFileWithHttpInfo($data, $apikey = null)
    {
        
        // verify the required parameter 'data' is set
        if ($data === null) {
            throw new \InvalidArgumentException('Missing the required parameter $data when calling pDFExtractorCSVExtractorFile');
        }
  
        // parse inputs
        $resourcePath = "/api/v1/pdfextractor/csvextractor/extract";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = ApiClient::selectHeaderAccept(array('application/json', 'text/json', 'application/xml', 'text/xml'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = ApiClient::selectHeaderContentType(array('application/json','text/json','application/xml','text/xml'));
  
        // query params
        
        if ($apikey !== null) {
            $queryParams['apikey'] = $this->apiClient->getSerializer()->toQueryValue($apikey);
        }
        
        
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // body params
        $_tempBody = null;
        if (isset($data)) {
            $_tempBody = $data;
        }
  
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath, 'POST',
                $queryParams, $httpBody,
                $headerParams, 'string'
            );
            
            if (!$response) {
                return array(null, $statusCode, $httpHeader);
            }

            return array(\Bytescout\Client\ObjectSerializer::deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader);
            
        } catch (ApiException $e) {
            switch ($e->getCode()) { 
            case 200:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 400:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 401:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 403:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 500:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\ExceptionResponse', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            }
  
            throw $e;
        }
    }
    
    /**
     * pDFExtractorCSVExtractorLink
     *
     * Convert PDF document to CSV
     *
     * @param string $apikey User&#39;s ApiKey (optional)
     * @param int $propertiesStartPageIndex Index of page (zero-based) of PDF file from which data will be extracted.\r\n            Default value: all pages (optional)
     * @param int $propertiesEndPageIndex Index of a page (zero-based) on which extracting of data will be finished.\r\n            Default value: all pages (optional)
     * @param string $propertiesCsvSeparatorSymbol Default value: , (optional)
     * @param string $propertiesCsvQuotaionSymbol Default value: \&quot; (optional)
     * @param double $propertiesXCoordinateToleranceFactor Default value: 20 (optional)
     * @param double $propertiesYCoordinateToleranceFactor Default value: 30 (optional)
     * @param int $propertiesTableXMinIntersectionRequiredInPercents Default value: 49 (optional)
     * @param int $propertiesTableYMinIntersectionRequiredInPercents Default value: 50 (optional)
     * @param bool $propertiesRtlTextAutoDetectionEnabled Default value: False (optional)
     * @param bool $propertiesExtractInvisibleText Default value: True (optional)
     * @param bool $propertiesExtractShadowLikeText Default value: True (optional)
     * @param bool $propertiesUnwrap Default value: False (optional)
     * @param bool $propertiesRemoveHyphenation Default value: True (optional)
     * @param bool $propertiesAutoAlignColumnsToHeader Default value: True (optional)
     * @param bool $propertiesPreserveFormattingOnTextExtraction Value indicating whether to preserve the text formatting on the extraction.\r\n            Default value: True (optional)
     * @param bool $propertiesDetectLinesInsteadOfParagraphs Default value: True (optional)
     * @param bool $propertiesTrimSpaces Default value: True (optional)
     * @param bool $propertiesExtractColumnByColumn Default value: False (optional)
     * @param float $propertiesDetectNewColumnBySpacesRatio Space ratio between words.\r\n            Default value: 1 (optional)
     * @param string $propertiesOcrMode Recognize text on embedded images using Optical Character Recognition (OCR). Set the language using OCRLanguage property.\r\n            Default value: Off (optional)
     * @param string $propertiesLineGroupingMode Default value: None (optional)
     * @param string $propertiesColumnDetectionMode Default value: ContentGroupsAndBorders (optional)
     * @param string $propertiesOcrCacheMode Default value: Off (optional)
     * @param string $propertiesOcrLanguage Default value: eng (optional)
     * @param float $propertiesOcrResolution Default value: 300 (optional)
     * @param int $propertiesTextEncodingCodePage Default value: 1252 (optional)
     * @param bool $propertiesConsiderFontNames Default value: False (optional)
     * @param bool $propertiesConsiderFontSizes Default value: False (optional)
     * @param bool $propertiesConsiderFontColors Default value: False (optional)
     * @param bool $propertiesConsiderVerticalBorders Default value: True (optional)
     * @param string $propertiesPassword Default value: (optional)
     * @param bool $propertiesCheckPermissions Default value: True (optional)
     * @param string $propertiesExtractionAreaUsageMode Default value: UseAllIntersectingObjects (optional)
     * @param string $outputType Type in which you want to get result of extracting (optional). Default value: Content. \r\n            IMPORTANT: \r\n            Link type generates public unique link to download, file is removed after default StorageTime(see File API). \r\n            LinkPrivate generates private unique link which should NOT be shared as it can be accessed with your api key only! (optional)
     * @param string $input Input Data (optional)
     * @param string $inputType Type of Input Data (optional)
     * @return string
     * @throws \Bytescout\Client\ApiException on non-2xx response
     */
    public function pDFExtractorCSVExtractorLink($apikey = null, $propertiesStartPageIndex = null, $propertiesEndPageIndex = null, $propertiesCsvSeparatorSymbol = null, $propertiesCsvQuotaionSymbol = null, $propertiesXCoordinateToleranceFactor = null, $propertiesYCoordinateToleranceFactor = null, $propertiesTableXMinIntersectionRequiredInPercents = null, $propertiesTableYMinIntersectionRequiredInPercents = null, $propertiesRtlTextAutoDetectionEnabled = null, $propertiesExtractInvisibleText = null, $propertiesExtractShadowLikeText = null, $propertiesUnwrap = null, $propertiesRemoveHyphenation = null, $propertiesAutoAlignColumnsToHeader = null, $propertiesPreserveFormattingOnTextExtraction = null, $propertiesDetectLinesInsteadOfParagraphs = null, $propertiesTrimSpaces = null, $propertiesExtractColumnByColumn = null, $propertiesDetectNewColumnBySpacesRatio = null, $propertiesOcrMode = null, $propertiesLineGroupingMode = null, $propertiesColumnDetectionMode = null, $propertiesOcrCacheMode = null, $propertiesOcrLanguage = null, $propertiesOcrResolution = null, $propertiesTextEncodingCodePage = null, $propertiesConsiderFontNames = null, $propertiesConsiderFontSizes = null, $propertiesConsiderFontColors = null, $propertiesConsiderVerticalBorders = null, $propertiesPassword = null, $propertiesCheckPermissions = null, $propertiesExtractionAreaUsageMode = null, $outputType = null, $input = null, $inputType = null)
    {
        list($response, $statusCode, $httpHeader) = $this->pDFExtractorCSVExtractorLinkWithHttpInfo ($apikey, $propertiesStartPageIndex, $propertiesEndPageIndex, $propertiesCsvSeparatorSymbol, $propertiesCsvQuotaionSymbol, $propertiesXCoordinateToleranceFactor, $propertiesYCoordinateToleranceFactor, $propertiesTableXMinIntersectionRequiredInPercents, $propertiesTableYMinIntersectionRequiredInPercents, $propertiesRtlTextAutoDetectionEnabled, $propertiesExtractInvisibleText, $propertiesExtractShadowLikeText, $propertiesUnwrap, $propertiesRemoveHyphenation, $propertiesAutoAlignColumnsToHeader, $propertiesPreserveFormattingOnTextExtraction, $propertiesDetectLinesInsteadOfParagraphs, $propertiesTrimSpaces, $propertiesExtractColumnByColumn, $propertiesDetectNewColumnBySpacesRatio, $propertiesOcrMode, $propertiesLineGroupingMode, $propertiesColumnDetectionMode, $propertiesOcrCacheMode, $propertiesOcrLanguage, $propertiesOcrResolution, $propertiesTextEncodingCodePage, $propertiesConsiderFontNames, $propertiesConsiderFontSizes, $propertiesConsiderFontColors, $propertiesConsiderVerticalBorders, $propertiesPassword, $propertiesCheckPermissions, $propertiesExtractionAreaUsageMode, $outputType, $input, $inputType);
        return $response; 
    }


    /**
     * pDFExtractorCSVExtractorLinkWithHttpInfo
     *
     * Convert PDF document to CSV
     *
     * @param string $apikey User&#39;s ApiKey (optional)
     * @param int $propertiesStartPageIndex Index of page (zero-based) of PDF file from which data will be extracted.\r\n            Default value: all pages (optional)
     * @param int $propertiesEndPageIndex Index of a page (zero-based) on which extracting of data will be finished.\r\n            Default value: all pages (optional)
     * @param string $propertiesCsvSeparatorSymbol Default value: , (optional)
     * @param string $propertiesCsvQuotaionSymbol Default value: \&quot; (optional)
     * @param double $propertiesXCoordinateToleranceFactor Default value: 20 (optional)
     * @param double $propertiesYCoordinateToleranceFactor Default value: 30 (optional)
     * @param int $propertiesTableXMinIntersectionRequiredInPercents Default value: 49 (optional)
     * @param int $propertiesTableYMinIntersectionRequiredInPercents Default value: 50 (optional)
     * @param bool $propertiesRtlTextAutoDetectionEnabled Default value: False (optional)
     * @param bool $propertiesExtractInvisibleText Default value: True (optional)
     * @param bool $propertiesExtractShadowLikeText Default value: True (optional)
     * @param bool $propertiesUnwrap Default value: False (optional)
     * @param bool $propertiesRemoveHyphenation Default value: True (optional)
     * @param bool $propertiesAutoAlignColumnsToHeader Default value: True (optional)
     * @param bool $propertiesPreserveFormattingOnTextExtraction Value indicating whether to preserve the text formatting on the extraction.\r\n            Default value: True (optional)
     * @param bool $propertiesDetectLinesInsteadOfParagraphs Default value: True (optional)
     * @param bool $propertiesTrimSpaces Default value: True (optional)
     * @param bool $propertiesExtractColumnByColumn Default value: False (optional)
     * @param float $propertiesDetectNewColumnBySpacesRatio Space ratio between words.\r\n            Default value: 1 (optional)
     * @param string $propertiesOcrMode Recognize text on embedded images using Optical Character Recognition (OCR). Set the language using OCRLanguage property.\r\n            Default value: Off (optional)
     * @param string $propertiesLineGroupingMode Default value: None (optional)
     * @param string $propertiesColumnDetectionMode Default value: ContentGroupsAndBorders (optional)
     * @param string $propertiesOcrCacheMode Default value: Off (optional)
     * @param string $propertiesOcrLanguage Default value: eng (optional)
     * @param float $propertiesOcrResolution Default value: 300 (optional)
     * @param int $propertiesTextEncodingCodePage Default value: 1252 (optional)
     * @param bool $propertiesConsiderFontNames Default value: False (optional)
     * @param bool $propertiesConsiderFontSizes Default value: False (optional)
     * @param bool $propertiesConsiderFontColors Default value: False (optional)
     * @param bool $propertiesConsiderVerticalBorders Default value: True (optional)
     * @param string $propertiesPassword Default value: (optional)
     * @param bool $propertiesCheckPermissions Default value: True (optional)
     * @param string $propertiesExtractionAreaUsageMode Default value: UseAllIntersectingObjects (optional)
     * @param string $outputType Type in which you want to get result of extracting (optional). Default value: Content. \r\n            IMPORTANT: \r\n            Link type generates public unique link to download, file is removed after default StorageTime(see File API). \r\n            LinkPrivate generates private unique link which should NOT be shared as it can be accessed with your api key only! (optional)
     * @param string $input Input Data (optional)
     * @param string $inputType Type of Input Data (optional)
     * @return Array of string, HTTP status code, HTTP response headers (array of strings)
     * @throws \Bytescout\Client\ApiException on non-2xx response
     */
    public function pDFExtractorCSVExtractorLinkWithHttpInfo($apikey = null, $propertiesStartPageIndex = null, $propertiesEndPageIndex = null, $propertiesCsvSeparatorSymbol = null, $propertiesCsvQuotaionSymbol = null, $propertiesXCoordinateToleranceFactor = null, $propertiesYCoordinateToleranceFactor = null, $propertiesTableXMinIntersectionRequiredInPercents = null, $propertiesTableYMinIntersectionRequiredInPercents = null, $propertiesRtlTextAutoDetectionEnabled = null, $propertiesExtractInvisibleText = null, $propertiesExtractShadowLikeText = null, $propertiesUnwrap = null, $propertiesRemoveHyphenation = null, $propertiesAutoAlignColumnsToHeader = null, $propertiesPreserveFormattingOnTextExtraction = null, $propertiesDetectLinesInsteadOfParagraphs = null, $propertiesTrimSpaces = null, $propertiesExtractColumnByColumn = null, $propertiesDetectNewColumnBySpacesRatio = null, $propertiesOcrMode = null, $propertiesLineGroupingMode = null, $propertiesColumnDetectionMode = null, $propertiesOcrCacheMode = null, $propertiesOcrLanguage = null, $propertiesOcrResolution = null, $propertiesTextEncodingCodePage = null, $propertiesConsiderFontNames = null, $propertiesConsiderFontSizes = null, $propertiesConsiderFontColors = null, $propertiesConsiderVerticalBorders = null, $propertiesPassword = null, $propertiesCheckPermissions = null, $propertiesExtractionAreaUsageMode = null, $outputType = null, $input = null, $inputType = null)
    {
        
  
        // parse inputs
        $resourcePath = "/api/v1/pdfextractor/csvextractor/extract";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = ApiClient::selectHeaderAccept(array('application/json', 'text/json', 'application/xml', 'text/xml'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = ApiClient::selectHeaderContentType(array());
  
        // query params
        
        if ($apikey !== null) {
            $queryParams['apikey'] = $this->apiClient->getSerializer()->toQueryValue($apikey);
        }// query params
        
        if ($propertiesStartPageIndex !== null) {
            $queryParams['properties.startPageIndex'] = $this->apiClient->getSerializer()->toQueryValue($propertiesStartPageIndex);
        }// query params
        
        if ($propertiesEndPageIndex !== null) {
            $queryParams['properties.endPageIndex'] = $this->apiClient->getSerializer()->toQueryValue($propertiesEndPageIndex);
        }// query params
        
        if ($propertiesCsvSeparatorSymbol !== null) {
            $queryParams['properties.csvSeparatorSymbol'] = $this->apiClient->getSerializer()->toQueryValue($propertiesCsvSeparatorSymbol);
        }// query params
        
        if ($propertiesCsvQuotaionSymbol !== null) {
            $queryParams['properties.csvQuotaionSymbol'] = $this->apiClient->getSerializer()->toQueryValue($propertiesCsvQuotaionSymbol);
        }// query params
        
        if ($propertiesXCoordinateToleranceFactor !== null) {
            $queryParams['properties.xCoordinateToleranceFactor'] = $this->apiClient->getSerializer()->toQueryValue($propertiesXCoordinateToleranceFactor);
        }// query params
        
        if ($propertiesYCoordinateToleranceFactor !== null) {
            $queryParams['properties.yCoordinateToleranceFactor'] = $this->apiClient->getSerializer()->toQueryValue($propertiesYCoordinateToleranceFactor);
        }// query params
        
        if ($propertiesTableXMinIntersectionRequiredInPercents !== null) {
            $queryParams['properties.tableXMinIntersectionRequiredInPercents'] = $this->apiClient->getSerializer()->toQueryValue($propertiesTableXMinIntersectionRequiredInPercents);
        }// query params
        
        if ($propertiesTableYMinIntersectionRequiredInPercents !== null) {
            $queryParams['properties.tableYMinIntersectionRequiredInPercents'] = $this->apiClient->getSerializer()->toQueryValue($propertiesTableYMinIntersectionRequiredInPercents);
        }// query params
        
        if ($propertiesRtlTextAutoDetectionEnabled !== null) {
            $queryParams['properties.rtlTextAutoDetectionEnabled'] = $this->apiClient->getSerializer()->toQueryValue($propertiesRtlTextAutoDetectionEnabled);
        }// query params
        
        if ($propertiesExtractInvisibleText !== null) {
            $queryParams['properties.extractInvisibleText'] = $this->apiClient->getSerializer()->toQueryValue($propertiesExtractInvisibleText);
        }// query params
        
        if ($propertiesExtractShadowLikeText !== null) {
            $queryParams['properties.extractShadowLikeText'] = $this->apiClient->getSerializer()->toQueryValue($propertiesExtractShadowLikeText);
        }// query params
        
        if ($propertiesUnwrap !== null) {
            $queryParams['properties.unwrap'] = $this->apiClient->getSerializer()->toQueryValue($propertiesUnwrap);
        }// query params
        
        if ($propertiesRemoveHyphenation !== null) {
            $queryParams['properties.removeHyphenation'] = $this->apiClient->getSerializer()->toQueryValue($propertiesRemoveHyphenation);
        }// query params
        
        if ($propertiesAutoAlignColumnsToHeader !== null) {
            $queryParams['properties.autoAlignColumnsToHeader'] = $this->apiClient->getSerializer()->toQueryValue($propertiesAutoAlignColumnsToHeader);
        }// query params
        
        if ($propertiesPreserveFormattingOnTextExtraction !== null) {
            $queryParams['properties.preserveFormattingOnTextExtraction'] = $this->apiClient->getSerializer()->toQueryValue($propertiesPreserveFormattingOnTextExtraction);
        }// query params
        
        if ($propertiesDetectLinesInsteadOfParagraphs !== null) {
            $queryParams['properties.detectLinesInsteadOfParagraphs'] = $this->apiClient->getSerializer()->toQueryValue($propertiesDetectLinesInsteadOfParagraphs);
        }// query params
        
        if ($propertiesTrimSpaces !== null) {
            $queryParams['properties.trimSpaces'] = $this->apiClient->getSerializer()->toQueryValue($propertiesTrimSpaces);
        }// query params
        
        if ($propertiesExtractColumnByColumn !== null) {
            $queryParams['properties.extractColumnByColumn'] = $this->apiClient->getSerializer()->toQueryValue($propertiesExtractColumnByColumn);
        }// query params
        
        if ($propertiesDetectNewColumnBySpacesRatio !== null) {
            $queryParams['properties.detectNewColumnBySpacesRatio'] = $this->apiClient->getSerializer()->toQueryValue($propertiesDetectNewColumnBySpacesRatio);
        }// query params
        
        if ($propertiesOcrMode !== null) {
            $queryParams['properties.ocrMode'] = $this->apiClient->getSerializer()->toQueryValue($propertiesOcrMode);
        }// query params
        
        if ($propertiesLineGroupingMode !== null) {
            $queryParams['properties.lineGroupingMode'] = $this->apiClient->getSerializer()->toQueryValue($propertiesLineGroupingMode);
        }// query params
        
        if ($propertiesColumnDetectionMode !== null) {
            $queryParams['properties.columnDetectionMode'] = $this->apiClient->getSerializer()->toQueryValue($propertiesColumnDetectionMode);
        }// query params
        
        if ($propertiesOcrCacheMode !== null) {
            $queryParams['properties.ocrCacheMode'] = $this->apiClient->getSerializer()->toQueryValue($propertiesOcrCacheMode);
        }// query params
        
        if ($propertiesOcrLanguage !== null) {
            $queryParams['properties.ocrLanguage'] = $this->apiClient->getSerializer()->toQueryValue($propertiesOcrLanguage);
        }// query params
        
        if ($propertiesOcrResolution !== null) {
            $queryParams['properties.ocrResolution'] = $this->apiClient->getSerializer()->toQueryValue($propertiesOcrResolution);
        }// query params
        
        if ($propertiesTextEncodingCodePage !== null) {
            $queryParams['properties.textEncodingCodePage'] = $this->apiClient->getSerializer()->toQueryValue($propertiesTextEncodingCodePage);
        }// query params
        
        if ($propertiesConsiderFontNames !== null) {
            $queryParams['properties.considerFontNames'] = $this->apiClient->getSerializer()->toQueryValue($propertiesConsiderFontNames);
        }// query params
        
        if ($propertiesConsiderFontSizes !== null) {
            $queryParams['properties.considerFontSizes'] = $this->apiClient->getSerializer()->toQueryValue($propertiesConsiderFontSizes);
        }// query params
        
        if ($propertiesConsiderFontColors !== null) {
            $queryParams['properties.considerFontColors'] = $this->apiClient->getSerializer()->toQueryValue($propertiesConsiderFontColors);
        }// query params
        
        if ($propertiesConsiderVerticalBorders !== null) {
            $queryParams['properties.considerVerticalBorders'] = $this->apiClient->getSerializer()->toQueryValue($propertiesConsiderVerticalBorders);
        }// query params
        
        if ($propertiesPassword !== null) {
            $queryParams['properties.password'] = $this->apiClient->getSerializer()->toQueryValue($propertiesPassword);
        }// query params
        
        if ($propertiesCheckPermissions !== null) {
            $queryParams['properties.checkPermissions'] = $this->apiClient->getSerializer()->toQueryValue($propertiesCheckPermissions);
        }// query params
        
        if ($propertiesExtractionAreaUsageMode !== null) {
            $queryParams['properties.extractionAreaUsageMode'] = $this->apiClient->getSerializer()->toQueryValue($propertiesExtractionAreaUsageMode);
        }// query params
        
        if ($outputType !== null) {
            $queryParams['outputType'] = $this->apiClient->getSerializer()->toQueryValue($outputType);
        }// query params
        
        if ($input !== null) {
            $queryParams['input'] = $this->apiClient->getSerializer()->toQueryValue($input);
        }// query params
        
        if ($inputType !== null) {
            $queryParams['inputType'] = $this->apiClient->getSerializer()->toQueryValue($inputType);
        }
        
        
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        
  
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath, 'GET',
                $queryParams, $httpBody,
                $headerParams, 'string'
            );
            
            if (!$response) {
                return array(null, $statusCode, $httpHeader);
            }

            return array(\Bytescout\Client\ObjectSerializer::deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader);
            
        } catch (ApiException $e) {
            switch ($e->getCode()) { 
            case 200:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 400:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 401:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 403:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 500:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\ExceptionResponse', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            }
  
            throw $e;
        }
    }
    
    /**
     * pDFExtractorDocumentMergerGet
     *
     * Merge PDF documents
     *
     * @param string $apikey User&#39;s ApiKey (optional)
     * @param bool $propertiesCheckPermissions Default value: True (optional)
     * @param string $outputType Type in which you want to get result of extracting (optional). Default value: Content. \r\n            IMPORTANT: \r\n            Link type generates public unique link to download, file is removed after default StorageTime(see File API). \r\n            LinkPrivate generates private unique link which should NOT be shared as it can be accessed with your api key only! (optional)
     * @param string[] $inputFileIds  (optional)
     * @return string
     * @throws \Bytescout\Client\ApiException on non-2xx response
     */
    public function pDFExtractorDocumentMergerGet($apikey = null, $propertiesCheckPermissions = null, $outputType = null, $inputFileIds = null)
    {
        list($response, $statusCode, $httpHeader) = $this->pDFExtractorDocumentMergerGetWithHttpInfo ($apikey, $propertiesCheckPermissions, $outputType, $inputFileIds);
        return $response; 
    }


    /**
     * pDFExtractorDocumentMergerGetWithHttpInfo
     *
     * Merge PDF documents
     *
     * @param string $apikey User&#39;s ApiKey (optional)
     * @param bool $propertiesCheckPermissions Default value: True (optional)
     * @param string $outputType Type in which you want to get result of extracting (optional). Default value: Content. \r\n            IMPORTANT: \r\n            Link type generates public unique link to download, file is removed after default StorageTime(see File API). \r\n            LinkPrivate generates private unique link which should NOT be shared as it can be accessed with your api key only! (optional)
     * @param string[] $inputFileIds  (optional)
     * @return Array of string, HTTP status code, HTTP response headers (array of strings)
     * @throws \Bytescout\Client\ApiException on non-2xx response
     */
    public function pDFExtractorDocumentMergerGetWithHttpInfo($apikey = null, $propertiesCheckPermissions = null, $outputType = null, $inputFileIds = null)
    {
        
  
        // parse inputs
        $resourcePath = "/api/v1/pdfextractor/documentmerger";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = ApiClient::selectHeaderAccept(array('application/json', 'text/json', 'application/xml', 'text/xml'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = ApiClient::selectHeaderContentType(array());
  
        // query params
        
        if ($apikey !== null) {
            $queryParams['apikey'] = $this->apiClient->getSerializer()->toQueryValue($apikey);
        }// query params
        
        if ($propertiesCheckPermissions !== null) {
            $queryParams['properties.checkPermissions'] = $this->apiClient->getSerializer()->toQueryValue($propertiesCheckPermissions);
        }// query params
        
        if ($outputType !== null) {
            $queryParams['outputType'] = $this->apiClient->getSerializer()->toQueryValue($outputType);
        }// query params
        
        if (is_array($inputFileIds)) {
            $inputFileIds = $this->apiClient->getSerializer()->serializeCollection($inputFileIds, 'multi', true);
        }
        
        if ($inputFileIds !== null) {
            $queryParams['inputFileIds'] = $this->apiClient->getSerializer()->toQueryValue($inputFileIds);
        }
        
        
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        
  
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath, 'GET',
                $queryParams, $httpBody,
                $headerParams, 'string'
            );
            
            if (!$response) {
                return array(null, $statusCode, $httpHeader);
            }

            return array(\Bytescout\Client\ObjectSerializer::deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader);
            
        } catch (ApiException $e) {
            switch ($e->getCode()) { 
            case 200:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 400:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 401:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 403:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 500:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\ExceptionResponse', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            }
  
            throw $e;
        }
    }
    
    /**
     * pDFExtractorDocumentMergerPost
     *
     * Merge PDF documents
     *
     * @param \Bytescout\Client\Model\DocumentMergerRequestVm $data  (required)
     * @param string $apikey User&#39;s ApiKey (optional)
     * @return string
     * @throws \Bytescout\Client\ApiException on non-2xx response
     */
    public function pDFExtractorDocumentMergerPost($data, $apikey = null)
    {
        list($response, $statusCode, $httpHeader) = $this->pDFExtractorDocumentMergerPostWithHttpInfo ($data, $apikey);
        return $response; 
    }


    /**
     * pDFExtractorDocumentMergerPostWithHttpInfo
     *
     * Merge PDF documents
     *
     * @param \Bytescout\Client\Model\DocumentMergerRequestVm $data  (required)
     * @param string $apikey User&#39;s ApiKey (optional)
     * @return Array of string, HTTP status code, HTTP response headers (array of strings)
     * @throws \Bytescout\Client\ApiException on non-2xx response
     */
    public function pDFExtractorDocumentMergerPostWithHttpInfo($data, $apikey = null)
    {
        
        // verify the required parameter 'data' is set
        if ($data === null) {
            throw new \InvalidArgumentException('Missing the required parameter $data when calling pDFExtractorDocumentMergerPost');
        }
  
        // parse inputs
        $resourcePath = "/api/v1/pdfextractor/documentmerger";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = ApiClient::selectHeaderAccept(array('application/json', 'text/json', 'application/xml', 'text/xml'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = ApiClient::selectHeaderContentType(array('application/json','text/json','application/xml','text/xml'));
  
        // query params
        
        if ($apikey !== null) {
            $queryParams['apikey'] = $this->apiClient->getSerializer()->toQueryValue($apikey);
        }
        
        
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // body params
        $_tempBody = null;
        if (isset($data)) {
            $_tempBody = $data;
        }
  
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath, 'POST',
                $queryParams, $httpBody,
                $headerParams, 'string'
            );
            
            if (!$response) {
                return array(null, $statusCode, $httpHeader);
            }

            return array(\Bytescout\Client\ObjectSerializer::deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader);
            
        } catch (ApiException $e) {
            switch ($e->getCode()) { 
            case 200:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 400:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 401:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 403:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 500:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\ExceptionResponse', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            }
  
            throw $e;
        }
    }
    
    /**
     * pDFExtractorDocumentSplitterGet
     *
     * Split PDF document
     *
     * @param string $apikey User&#39;s ApiKey (optional)
     * @param bool $propertiesOptimizeSplittedDocuments Default value: False (optional)
     * @param bool $propertiesCheckPermissions Default value: True (optional)
     * @param string $propertiesRanges Comma-separated list of page ranges in form \&quot;1-4,5,7,8-15,16-\&quot;. Page numbers are 1-based. Ending \&quot;-\&quot; means \&quot;to the last page\&quot;. (required) (optional)
     * @param string $outputType Type in which you want to get result of extracting (optional). Default value: FileId.\r\n            IMPORTANT: \r\n            Link type generates public unique link to download, file is removed after default StorageTime(see File API). \r\n            LinkPrivate generates private unique link which should NOT be shared as it can be accessed with your api key only! (optional)
     * @param string $input Input Data (optional)
     * @param string $inputType Type of Input Data (optional)
     * @return string
     * @throws \Bytescout\Client\ApiException on non-2xx response
     */
    public function pDFExtractorDocumentSplitterGet($apikey = null, $propertiesOptimizeSplittedDocuments = null, $propertiesCheckPermissions = null, $propertiesRanges = null, $outputType = null, $input = null, $inputType = null)
    {
        list($response, $statusCode, $httpHeader) = $this->pDFExtractorDocumentSplitterGetWithHttpInfo ($apikey, $propertiesOptimizeSplittedDocuments, $propertiesCheckPermissions, $propertiesRanges, $outputType, $input, $inputType);
        return $response; 
    }


    /**
     * pDFExtractorDocumentSplitterGetWithHttpInfo
     *
     * Split PDF document
     *
     * @param string $apikey User&#39;s ApiKey (optional)
     * @param bool $propertiesOptimizeSplittedDocuments Default value: False (optional)
     * @param bool $propertiesCheckPermissions Default value: True (optional)
     * @param string $propertiesRanges Comma-separated list of page ranges in form \&quot;1-4,5,7,8-15,16-\&quot;. Page numbers are 1-based. Ending \&quot;-\&quot; means \&quot;to the last page\&quot;. (required) (optional)
     * @param string $outputType Type in which you want to get result of extracting (optional). Default value: FileId.\r\n            IMPORTANT: \r\n            Link type generates public unique link to download, file is removed after default StorageTime(see File API). \r\n            LinkPrivate generates private unique link which should NOT be shared as it can be accessed with your api key only! (optional)
     * @param string $input Input Data (optional)
     * @param string $inputType Type of Input Data (optional)
     * @return Array of string, HTTP status code, HTTP response headers (array of strings)
     * @throws \Bytescout\Client\ApiException on non-2xx response
     */
    public function pDFExtractorDocumentSplitterGetWithHttpInfo($apikey = null, $propertiesOptimizeSplittedDocuments = null, $propertiesCheckPermissions = null, $propertiesRanges = null, $outputType = null, $input = null, $inputType = null)
    {
        
  
        // parse inputs
        $resourcePath = "/api/v1/pdfextractor/documentsplitter";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = ApiClient::selectHeaderAccept(array('application/json', 'text/json', 'application/xml', 'text/xml'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = ApiClient::selectHeaderContentType(array());
  
        // query params
        
        if ($apikey !== null) {
            $queryParams['apikey'] = $this->apiClient->getSerializer()->toQueryValue($apikey);
        }// query params
        
        if ($propertiesOptimizeSplittedDocuments !== null) {
            $queryParams['properties.optimizeSplittedDocuments'] = $this->apiClient->getSerializer()->toQueryValue($propertiesOptimizeSplittedDocuments);
        }// query params
        
        if ($propertiesCheckPermissions !== null) {
            $queryParams['properties.checkPermissions'] = $this->apiClient->getSerializer()->toQueryValue($propertiesCheckPermissions);
        }// query params
        
        if ($propertiesRanges !== null) {
            $queryParams['properties.ranges'] = $this->apiClient->getSerializer()->toQueryValue($propertiesRanges);
        }// query params
        
        if ($outputType !== null) {
            $queryParams['outputType'] = $this->apiClient->getSerializer()->toQueryValue($outputType);
        }// query params
        
        if ($input !== null) {
            $queryParams['input'] = $this->apiClient->getSerializer()->toQueryValue($input);
        }// query params
        
        if ($inputType !== null) {
            $queryParams['inputType'] = $this->apiClient->getSerializer()->toQueryValue($inputType);
        }
        
        
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        
  
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath, 'GET',
                $queryParams, $httpBody,
                $headerParams, 'string'
            );
            
            if (!$response) {
                return array(null, $statusCode, $httpHeader);
            }

            return array(\Bytescout\Client\ObjectSerializer::deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader);
            
        } catch (ApiException $e) {
            switch ($e->getCode()) { 
            case 200:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 400:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 401:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 403:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 500:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\ExceptionResponse', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            }
  
            throw $e;
        }
    }
    
    /**
     * pDFExtractorDocumentSplitterPost
     *
     * Split PDF document
     *
     * @param \Bytescout\Client\Model\DocumentSplitterRequestVm $data  (required)
     * @param string $apikey User&#39;s ApiKey (optional)
     * @return string
     * @throws \Bytescout\Client\ApiException on non-2xx response
     */
    public function pDFExtractorDocumentSplitterPost($data, $apikey = null)
    {
        list($response, $statusCode, $httpHeader) = $this->pDFExtractorDocumentSplitterPostWithHttpInfo ($data, $apikey);
        return $response; 
    }


    /**
     * pDFExtractorDocumentSplitterPostWithHttpInfo
     *
     * Split PDF document
     *
     * @param \Bytescout\Client\Model\DocumentSplitterRequestVm $data  (required)
     * @param string $apikey User&#39;s ApiKey (optional)
     * @return Array of string, HTTP status code, HTTP response headers (array of strings)
     * @throws \Bytescout\Client\ApiException on non-2xx response
     */
    public function pDFExtractorDocumentSplitterPostWithHttpInfo($data, $apikey = null)
    {
        
        // verify the required parameter 'data' is set
        if ($data === null) {
            throw new \InvalidArgumentException('Missing the required parameter $data when calling pDFExtractorDocumentSplitterPost');
        }
  
        // parse inputs
        $resourcePath = "/api/v1/pdfextractor/documentsplitter";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = ApiClient::selectHeaderAccept(array('application/json', 'text/json', 'application/xml', 'text/xml'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = ApiClient::selectHeaderContentType(array('application/json','text/json','application/xml','text/xml'));
  
        // query params
        
        if ($apikey !== null) {
            $queryParams['apikey'] = $this->apiClient->getSerializer()->toQueryValue($apikey);
        }
        
        
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // body params
        $_tempBody = null;
        if (isset($data)) {
            $_tempBody = $data;
        }
  
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath, 'POST',
                $queryParams, $httpBody,
                $headerParams, 'string'
            );
            
            if (!$response) {
                return array(null, $statusCode, $httpHeader);
            }

            return array(\Bytescout\Client\ObjectSerializer::deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader);
            
        } catch (ApiException $e) {
            switch ($e->getCode()) { 
            case 200:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 400:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 401:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 403:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 500:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\ExceptionResponse', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            }
  
            throw $e;
        }
    }
    
    /**
     * pDFExtractorInfoExtractorFile
     *
     * Get PDF document information
     *
     * @param \Bytescout\Client\Model\InfoExtractorRequestVm $data  (required)
     * @param string $apikey User&#39;s ApiKey (optional)
     * @return string
     * @throws \Bytescout\Client\ApiException on non-2xx response
     */
    public function pDFExtractorInfoExtractorFile($data, $apikey = null)
    {
        list($response, $statusCode, $httpHeader) = $this->pDFExtractorInfoExtractorFileWithHttpInfo ($data, $apikey);
        return $response; 
    }


    /**
     * pDFExtractorInfoExtractorFileWithHttpInfo
     *
     * Get PDF document information
     *
     * @param \Bytescout\Client\Model\InfoExtractorRequestVm $data  (required)
     * @param string $apikey User&#39;s ApiKey (optional)
     * @return Array of string, HTTP status code, HTTP response headers (array of strings)
     * @throws \Bytescout\Client\ApiException on non-2xx response
     */
    public function pDFExtractorInfoExtractorFileWithHttpInfo($data, $apikey = null)
    {
        
        // verify the required parameter 'data' is set
        if ($data === null) {
            throw new \InvalidArgumentException('Missing the required parameter $data when calling pDFExtractorInfoExtractorFile');
        }
  
        // parse inputs
        $resourcePath = "/api/v1/pdfextractor/infoextractor/extract";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = ApiClient::selectHeaderAccept(array('application/json', 'text/json', 'application/xml', 'text/xml'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = ApiClient::selectHeaderContentType(array('application/json','text/json','application/xml','text/xml'));
  
        // query params
        
        if ($apikey !== null) {
            $queryParams['apikey'] = $this->apiClient->getSerializer()->toQueryValue($apikey);
        }
        
        
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // body params
        $_tempBody = null;
        if (isset($data)) {
            $_tempBody = $data;
        }
  
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath, 'POST',
                $queryParams, $httpBody,
                $headerParams, 'string'
            );
            
            if (!$response) {
                return array(null, $statusCode, $httpHeader);
            }

            return array(\Bytescout\Client\ObjectSerializer::deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader);
            
        } catch (ApiException $e) {
            switch ($e->getCode()) { 
            case 200:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 400:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 401:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 403:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 500:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\ExceptionResponse', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            }
  
            throw $e;
        }
    }
    
    /**
     * pDFExtractorInfoExtractorLink
     *
     * Get PDF document information
     *
     * @param string $apikey User&#39;s ApiKey (optional)
     * @param string $propertiesPassword  (optional)
     * @param bool $propertiesCheckPermissions Default value: True (optional)
     * @param string $propertiesExtractionAreaUsageMode Default value: UseAllIntersectingObjects (optional)
     * @param string $outputType Type in which you want to get result of extracting (optional). Default value: Content. \r\n            IMPORTANT: \r\n            Link type generates public unique link to download, file is removed after default StorageTime(see File API). \r\n            LinkPrivate generates private unique link which should NOT be shared as it can be accessed with your api key only! (optional)
     * @param string $input Input Data (optional)
     * @param string $inputType Type of Input Data (optional)
     * @return string
     * @throws \Bytescout\Client\ApiException on non-2xx response
     */
    public function pDFExtractorInfoExtractorLink($apikey = null, $propertiesPassword = null, $propertiesCheckPermissions = null, $propertiesExtractionAreaUsageMode = null, $outputType = null, $input = null, $inputType = null)
    {
        list($response, $statusCode, $httpHeader) = $this->pDFExtractorInfoExtractorLinkWithHttpInfo ($apikey, $propertiesPassword, $propertiesCheckPermissions, $propertiesExtractionAreaUsageMode, $outputType, $input, $inputType);
        return $response; 
    }


    /**
     * pDFExtractorInfoExtractorLinkWithHttpInfo
     *
     * Get PDF document information
     *
     * @param string $apikey User&#39;s ApiKey (optional)
     * @param string $propertiesPassword  (optional)
     * @param bool $propertiesCheckPermissions Default value: True (optional)
     * @param string $propertiesExtractionAreaUsageMode Default value: UseAllIntersectingObjects (optional)
     * @param string $outputType Type in which you want to get result of extracting (optional). Default value: Content. \r\n            IMPORTANT: \r\n            Link type generates public unique link to download, file is removed after default StorageTime(see File API). \r\n            LinkPrivate generates private unique link which should NOT be shared as it can be accessed with your api key only! (optional)
     * @param string $input Input Data (optional)
     * @param string $inputType Type of Input Data (optional)
     * @return Array of string, HTTP status code, HTTP response headers (array of strings)
     * @throws \Bytescout\Client\ApiException on non-2xx response
     */
    public function pDFExtractorInfoExtractorLinkWithHttpInfo($apikey = null, $propertiesPassword = null, $propertiesCheckPermissions = null, $propertiesExtractionAreaUsageMode = null, $outputType = null, $input = null, $inputType = null)
    {
        
  
        // parse inputs
        $resourcePath = "/api/v1/pdfextractor/infoextractor/extract";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = ApiClient::selectHeaderAccept(array('application/json', 'text/json', 'application/xml', 'text/xml'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = ApiClient::selectHeaderContentType(array());
  
        // query params
        
        if ($apikey !== null) {
            $queryParams['apikey'] = $this->apiClient->getSerializer()->toQueryValue($apikey);
        }// query params
        
        if ($propertiesPassword !== null) {
            $queryParams['properties.password'] = $this->apiClient->getSerializer()->toQueryValue($propertiesPassword);
        }// query params
        
        if ($propertiesCheckPermissions !== null) {
            $queryParams['properties.checkPermissions'] = $this->apiClient->getSerializer()->toQueryValue($propertiesCheckPermissions);
        }// query params
        
        if ($propertiesExtractionAreaUsageMode !== null) {
            $queryParams['properties.extractionAreaUsageMode'] = $this->apiClient->getSerializer()->toQueryValue($propertiesExtractionAreaUsageMode);
        }// query params
        
        if ($outputType !== null) {
            $queryParams['outputType'] = $this->apiClient->getSerializer()->toQueryValue($outputType);
        }// query params
        
        if ($input !== null) {
            $queryParams['input'] = $this->apiClient->getSerializer()->toQueryValue($input);
        }// query params
        
        if ($inputType !== null) {
            $queryParams['inputType'] = $this->apiClient->getSerializer()->toQueryValue($inputType);
        }
        
        
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        
  
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath, 'GET',
                $queryParams, $httpBody,
                $headerParams, 'string'
            );
            
            if (!$response) {
                return array(null, $statusCode, $httpHeader);
            }

            return array(\Bytescout\Client\ObjectSerializer::deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader);
            
        } catch (ApiException $e) {
            switch ($e->getCode()) { 
            case 200:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 400:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 401:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 403:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 500:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\ExceptionResponse', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            }
  
            throw $e;
        }
    }
    
    /**
     * pDFExtractorTextExtractorFile
     *
     * Convert PDF document to plain text (TXT)
     *
     * @param \Bytescout\Client\Model\TextExtractorRequestVm $data  (required)
     * @param string $apikey User&#39;s ApiKey (optional)
     * @return string
     * @throws \Bytescout\Client\ApiException on non-2xx response
     */
    public function pDFExtractorTextExtractorFile($data, $apikey = null)
    {
        list($response, $statusCode, $httpHeader) = $this->pDFExtractorTextExtractorFileWithHttpInfo ($data, $apikey);
        return $response; 
    }


    /**
     * pDFExtractorTextExtractorFileWithHttpInfo
     *
     * Convert PDF document to plain text (TXT)
     *
     * @param \Bytescout\Client\Model\TextExtractorRequestVm $data  (required)
     * @param string $apikey User&#39;s ApiKey (optional)
     * @return Array of string, HTTP status code, HTTP response headers (array of strings)
     * @throws \Bytescout\Client\ApiException on non-2xx response
     */
    public function pDFExtractorTextExtractorFileWithHttpInfo($data, $apikey = null)
    {
        
        // verify the required parameter 'data' is set
        if ($data === null) {
            throw new \InvalidArgumentException('Missing the required parameter $data when calling pDFExtractorTextExtractorFile');
        }
  
        // parse inputs
        $resourcePath = "/api/v1/pdfextractor/textextractor/extract";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = ApiClient::selectHeaderAccept(array('application/json', 'text/json', 'application/xml', 'text/xml'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = ApiClient::selectHeaderContentType(array('application/json','text/json','application/xml','text/xml'));
  
        // query params
        
        if ($apikey !== null) {
            $queryParams['apikey'] = $this->apiClient->getSerializer()->toQueryValue($apikey);
        }
        
        
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // body params
        $_tempBody = null;
        if (isset($data)) {
            $_tempBody = $data;
        }
  
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath, 'POST',
                $queryParams, $httpBody,
                $headerParams, 'string'
            );
            
            if (!$response) {
                return array(null, $statusCode, $httpHeader);
            }

            return array(\Bytescout\Client\ObjectSerializer::deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader);
            
        } catch (ApiException $e) {
            switch ($e->getCode()) { 
            case 200:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 400:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 401:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 403:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 500:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\ExceptionResponse', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            }
  
            throw $e;
        }
    }
    
    /**
     * pDFExtractorTextExtractorLink
     *
     * Convert PDF document to plain text (TXT)
     *
     * @param string $apikey User&#39;s ApiKey (optional)
     * @param int $propertiesStartPageIndex Index of page (zero-based) of PDF file from which data will be extracted.\r\n            Default value: all pages (optional)
     * @param int $propertiesEndPageIndex Index of a page (zero-based) on which extracting of data will be finished.\r\n            Default value: all pages (optional)
     * @param bool $propertiesRegexSearch Default value: False (optional)
     * @param string $propertiesWordMatchingMode Default value: SmartMatch (optional)
     * @param string $propertiesPageSeparator  (optional)
     * @param string $propertiesWordMatchingPunctuationMarks Default value: .\&quot;&#39;\u201C\u201D (optional)
     * @param double $propertiesXCoordinateToleranceFactor Default value: 20 (optional)
     * @param double $propertiesYCoordinateToleranceFactor Default value: 30 (optional)
     * @param int $propertiesTableXMinIntersectionRequiredInPercents Default value: 49 (optional)
     * @param int $propertiesTableYMinIntersectionRequiredInPercents Default value: 50 (optional)
     * @param bool $propertiesRtlTextAutoDetectionEnabled Default value: False (optional)
     * @param bool $propertiesExtractInvisibleText Default value: True (optional)
     * @param bool $propertiesExtractShadowLikeText Default value: True (optional)
     * @param bool $propertiesUnwrap Default value: False (optional)
     * @param bool $propertiesRemoveHyphenation Default value: True (optional)
     * @param bool $propertiesAutoAlignColumnsToHeader Default value: True (optional)
     * @param bool $propertiesPreserveFormattingOnTextExtraction Value indicating whether to preserve the text formatting on the extraction.\r\n            Default value: True (optional)
     * @param bool $propertiesDetectLinesInsteadOfParagraphs Default value: True (optional)
     * @param bool $propertiesTrimSpaces Default value: False (optional)
     * @param bool $propertiesExtractColumnByColumn Default value: False (optional)
     * @param float $propertiesDetectNewColumnBySpacesRatio Space ratio between words.\r\n            Default value: 1.2 (optional)
     * @param string $propertiesOcrMode Recognize text on embedded images using Optical Character Recognition (OCR). Set the language using OCRLanguage property.\r\n            Default value: Off (optional)
     * @param string $propertiesLineGroupingMode Default value: None (optional)
     * @param string $propertiesColumnDetectionMode Default value: ContentGroupsAndBorders (optional)
     * @param string $propertiesOcrCacheMode Default value: Off (optional)
     * @param string $propertiesOcrLanguage Default value: eng (optional)
     * @param float $propertiesOcrResolution Default value: 300 (optional)
     * @param int $propertiesTextEncodingCodePage Default value: 1252 (optional)
     * @param bool $propertiesConsiderFontNames Default value: False (optional)
     * @param bool $propertiesConsiderFontSizes Default value: False (optional)
     * @param bool $propertiesConsiderFontColors Default value: False (optional)
     * @param bool $propertiesConsiderVerticalBorders Default value: False (optional)
     * @param string $propertiesPassword Default value: (optional)
     * @param bool $propertiesCheckPermissions Default value: True (optional)
     * @param string $propertiesExtractionAreaUsageMode Default value: UseAllIntersectingObjects (optional)
     * @param string $outputType Type in which you want to get result of extracting (optional). Default value: Content. \r\n            IMPORTANT: \r\n            Link type generates public unique link to download, file is removed after default StorageTime(see File API). \r\n            LinkPrivate generates private unique link which should NOT be shared as it can be accessed with your api key only! (optional)
     * @param string $input Input Data (optional)
     * @param string $inputType Type of Input Data (optional)
     * @return string
     * @throws \Bytescout\Client\ApiException on non-2xx response
     */
    public function pDFExtractorTextExtractorLink($apikey = null, $propertiesStartPageIndex = null, $propertiesEndPageIndex = null, $propertiesRegexSearch = null, $propertiesWordMatchingMode = null, $propertiesPageSeparator = null, $propertiesWordMatchingPunctuationMarks = null, $propertiesXCoordinateToleranceFactor = null, $propertiesYCoordinateToleranceFactor = null, $propertiesTableXMinIntersectionRequiredInPercents = null, $propertiesTableYMinIntersectionRequiredInPercents = null, $propertiesRtlTextAutoDetectionEnabled = null, $propertiesExtractInvisibleText = null, $propertiesExtractShadowLikeText = null, $propertiesUnwrap = null, $propertiesRemoveHyphenation = null, $propertiesAutoAlignColumnsToHeader = null, $propertiesPreserveFormattingOnTextExtraction = null, $propertiesDetectLinesInsteadOfParagraphs = null, $propertiesTrimSpaces = null, $propertiesExtractColumnByColumn = null, $propertiesDetectNewColumnBySpacesRatio = null, $propertiesOcrMode = null, $propertiesLineGroupingMode = null, $propertiesColumnDetectionMode = null, $propertiesOcrCacheMode = null, $propertiesOcrLanguage = null, $propertiesOcrResolution = null, $propertiesTextEncodingCodePage = null, $propertiesConsiderFontNames = null, $propertiesConsiderFontSizes = null, $propertiesConsiderFontColors = null, $propertiesConsiderVerticalBorders = null, $propertiesPassword = null, $propertiesCheckPermissions = null, $propertiesExtractionAreaUsageMode = null, $outputType = null, $input = null, $inputType = null)
    {
        list($response, $statusCode, $httpHeader) = $this->pDFExtractorTextExtractorLinkWithHttpInfo ($apikey, $propertiesStartPageIndex, $propertiesEndPageIndex, $propertiesRegexSearch, $propertiesWordMatchingMode, $propertiesPageSeparator, $propertiesWordMatchingPunctuationMarks, $propertiesXCoordinateToleranceFactor, $propertiesYCoordinateToleranceFactor, $propertiesTableXMinIntersectionRequiredInPercents, $propertiesTableYMinIntersectionRequiredInPercents, $propertiesRtlTextAutoDetectionEnabled, $propertiesExtractInvisibleText, $propertiesExtractShadowLikeText, $propertiesUnwrap, $propertiesRemoveHyphenation, $propertiesAutoAlignColumnsToHeader, $propertiesPreserveFormattingOnTextExtraction, $propertiesDetectLinesInsteadOfParagraphs, $propertiesTrimSpaces, $propertiesExtractColumnByColumn, $propertiesDetectNewColumnBySpacesRatio, $propertiesOcrMode, $propertiesLineGroupingMode, $propertiesColumnDetectionMode, $propertiesOcrCacheMode, $propertiesOcrLanguage, $propertiesOcrResolution, $propertiesTextEncodingCodePage, $propertiesConsiderFontNames, $propertiesConsiderFontSizes, $propertiesConsiderFontColors, $propertiesConsiderVerticalBorders, $propertiesPassword, $propertiesCheckPermissions, $propertiesExtractionAreaUsageMode, $outputType, $input, $inputType);
        return $response; 
    }


    /**
     * pDFExtractorTextExtractorLinkWithHttpInfo
     *
     * Convert PDF document to plain text (TXT)
     *
     * @param string $apikey User&#39;s ApiKey (optional)
     * @param int $propertiesStartPageIndex Index of page (zero-based) of PDF file from which data will be extracted.\r\n            Default value: all pages (optional)
     * @param int $propertiesEndPageIndex Index of a page (zero-based) on which extracting of data will be finished.\r\n            Default value: all pages (optional)
     * @param bool $propertiesRegexSearch Default value: False (optional)
     * @param string $propertiesWordMatchingMode Default value: SmartMatch (optional)
     * @param string $propertiesPageSeparator  (optional)
     * @param string $propertiesWordMatchingPunctuationMarks Default value: .\&quot;&#39;\u201C\u201D (optional)
     * @param double $propertiesXCoordinateToleranceFactor Default value: 20 (optional)
     * @param double $propertiesYCoordinateToleranceFactor Default value: 30 (optional)
     * @param int $propertiesTableXMinIntersectionRequiredInPercents Default value: 49 (optional)
     * @param int $propertiesTableYMinIntersectionRequiredInPercents Default value: 50 (optional)
     * @param bool $propertiesRtlTextAutoDetectionEnabled Default value: False (optional)
     * @param bool $propertiesExtractInvisibleText Default value: True (optional)
     * @param bool $propertiesExtractShadowLikeText Default value: True (optional)
     * @param bool $propertiesUnwrap Default value: False (optional)
     * @param bool $propertiesRemoveHyphenation Default value: True (optional)
     * @param bool $propertiesAutoAlignColumnsToHeader Default value: True (optional)
     * @param bool $propertiesPreserveFormattingOnTextExtraction Value indicating whether to preserve the text formatting on the extraction.\r\n            Default value: True (optional)
     * @param bool $propertiesDetectLinesInsteadOfParagraphs Default value: True (optional)
     * @param bool $propertiesTrimSpaces Default value: False (optional)
     * @param bool $propertiesExtractColumnByColumn Default value: False (optional)
     * @param float $propertiesDetectNewColumnBySpacesRatio Space ratio between words.\r\n            Default value: 1.2 (optional)
     * @param string $propertiesOcrMode Recognize text on embedded images using Optical Character Recognition (OCR). Set the language using OCRLanguage property.\r\n            Default value: Off (optional)
     * @param string $propertiesLineGroupingMode Default value: None (optional)
     * @param string $propertiesColumnDetectionMode Default value: ContentGroupsAndBorders (optional)
     * @param string $propertiesOcrCacheMode Default value: Off (optional)
     * @param string $propertiesOcrLanguage Default value: eng (optional)
     * @param float $propertiesOcrResolution Default value: 300 (optional)
     * @param int $propertiesTextEncodingCodePage Default value: 1252 (optional)
     * @param bool $propertiesConsiderFontNames Default value: False (optional)
     * @param bool $propertiesConsiderFontSizes Default value: False (optional)
     * @param bool $propertiesConsiderFontColors Default value: False (optional)
     * @param bool $propertiesConsiderVerticalBorders Default value: False (optional)
     * @param string $propertiesPassword Default value: (optional)
     * @param bool $propertiesCheckPermissions Default value: True (optional)
     * @param string $propertiesExtractionAreaUsageMode Default value: UseAllIntersectingObjects (optional)
     * @param string $outputType Type in which you want to get result of extracting (optional). Default value: Content. \r\n            IMPORTANT: \r\n            Link type generates public unique link to download, file is removed after default StorageTime(see File API). \r\n            LinkPrivate generates private unique link which should NOT be shared as it can be accessed with your api key only! (optional)
     * @param string $input Input Data (optional)
     * @param string $inputType Type of Input Data (optional)
     * @return Array of string, HTTP status code, HTTP response headers (array of strings)
     * @throws \Bytescout\Client\ApiException on non-2xx response
     */
    public function pDFExtractorTextExtractorLinkWithHttpInfo($apikey = null, $propertiesStartPageIndex = null, $propertiesEndPageIndex = null, $propertiesRegexSearch = null, $propertiesWordMatchingMode = null, $propertiesPageSeparator = null, $propertiesWordMatchingPunctuationMarks = null, $propertiesXCoordinateToleranceFactor = null, $propertiesYCoordinateToleranceFactor = null, $propertiesTableXMinIntersectionRequiredInPercents = null, $propertiesTableYMinIntersectionRequiredInPercents = null, $propertiesRtlTextAutoDetectionEnabled = null, $propertiesExtractInvisibleText = null, $propertiesExtractShadowLikeText = null, $propertiesUnwrap = null, $propertiesRemoveHyphenation = null, $propertiesAutoAlignColumnsToHeader = null, $propertiesPreserveFormattingOnTextExtraction = null, $propertiesDetectLinesInsteadOfParagraphs = null, $propertiesTrimSpaces = null, $propertiesExtractColumnByColumn = null, $propertiesDetectNewColumnBySpacesRatio = null, $propertiesOcrMode = null, $propertiesLineGroupingMode = null, $propertiesColumnDetectionMode = null, $propertiesOcrCacheMode = null, $propertiesOcrLanguage = null, $propertiesOcrResolution = null, $propertiesTextEncodingCodePage = null, $propertiesConsiderFontNames = null, $propertiesConsiderFontSizes = null, $propertiesConsiderFontColors = null, $propertiesConsiderVerticalBorders = null, $propertiesPassword = null, $propertiesCheckPermissions = null, $propertiesExtractionAreaUsageMode = null, $outputType = null, $input = null, $inputType = null)
    {
        
  
        // parse inputs
        $resourcePath = "/api/v1/pdfextractor/textextractor/extract";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = ApiClient::selectHeaderAccept(array('application/json', 'text/json', 'application/xml', 'text/xml'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = ApiClient::selectHeaderContentType(array());
  
        // query params
        
        if ($apikey !== null) {
            $queryParams['apikey'] = $this->apiClient->getSerializer()->toQueryValue($apikey);
        }// query params
        
        if ($propertiesStartPageIndex !== null) {
            $queryParams['properties.startPageIndex'] = $this->apiClient->getSerializer()->toQueryValue($propertiesStartPageIndex);
        }// query params
        
        if ($propertiesEndPageIndex !== null) {
            $queryParams['properties.endPageIndex'] = $this->apiClient->getSerializer()->toQueryValue($propertiesEndPageIndex);
        }// query params
        
        if ($propertiesRegexSearch !== null) {
            $queryParams['properties.regexSearch'] = $this->apiClient->getSerializer()->toQueryValue($propertiesRegexSearch);
        }// query params
        
        if ($propertiesWordMatchingMode !== null) {
            $queryParams['properties.wordMatchingMode'] = $this->apiClient->getSerializer()->toQueryValue($propertiesWordMatchingMode);
        }// query params
        
        if ($propertiesPageSeparator !== null) {
            $queryParams['properties.pageSeparator'] = $this->apiClient->getSerializer()->toQueryValue($propertiesPageSeparator);
        }// query params
        
        if ($propertiesWordMatchingPunctuationMarks !== null) {
            $queryParams['properties.wordMatchingPunctuationMarks'] = $this->apiClient->getSerializer()->toQueryValue($propertiesWordMatchingPunctuationMarks);
        }// query params
        
        if ($propertiesXCoordinateToleranceFactor !== null) {
            $queryParams['properties.xCoordinateToleranceFactor'] = $this->apiClient->getSerializer()->toQueryValue($propertiesXCoordinateToleranceFactor);
        }// query params
        
        if ($propertiesYCoordinateToleranceFactor !== null) {
            $queryParams['properties.yCoordinateToleranceFactor'] = $this->apiClient->getSerializer()->toQueryValue($propertiesYCoordinateToleranceFactor);
        }// query params
        
        if ($propertiesTableXMinIntersectionRequiredInPercents !== null) {
            $queryParams['properties.tableXMinIntersectionRequiredInPercents'] = $this->apiClient->getSerializer()->toQueryValue($propertiesTableXMinIntersectionRequiredInPercents);
        }// query params
        
        if ($propertiesTableYMinIntersectionRequiredInPercents !== null) {
            $queryParams['properties.tableYMinIntersectionRequiredInPercents'] = $this->apiClient->getSerializer()->toQueryValue($propertiesTableYMinIntersectionRequiredInPercents);
        }// query params
        
        if ($propertiesRtlTextAutoDetectionEnabled !== null) {
            $queryParams['properties.rtlTextAutoDetectionEnabled'] = $this->apiClient->getSerializer()->toQueryValue($propertiesRtlTextAutoDetectionEnabled);
        }// query params
        
        if ($propertiesExtractInvisibleText !== null) {
            $queryParams['properties.extractInvisibleText'] = $this->apiClient->getSerializer()->toQueryValue($propertiesExtractInvisibleText);
        }// query params
        
        if ($propertiesExtractShadowLikeText !== null) {
            $queryParams['properties.extractShadowLikeText'] = $this->apiClient->getSerializer()->toQueryValue($propertiesExtractShadowLikeText);
        }// query params
        
        if ($propertiesUnwrap !== null) {
            $queryParams['properties.unwrap'] = $this->apiClient->getSerializer()->toQueryValue($propertiesUnwrap);
        }// query params
        
        if ($propertiesRemoveHyphenation !== null) {
            $queryParams['properties.removeHyphenation'] = $this->apiClient->getSerializer()->toQueryValue($propertiesRemoveHyphenation);
        }// query params
        
        if ($propertiesAutoAlignColumnsToHeader !== null) {
            $queryParams['properties.autoAlignColumnsToHeader'] = $this->apiClient->getSerializer()->toQueryValue($propertiesAutoAlignColumnsToHeader);
        }// query params
        
        if ($propertiesPreserveFormattingOnTextExtraction !== null) {
            $queryParams['properties.preserveFormattingOnTextExtraction'] = $this->apiClient->getSerializer()->toQueryValue($propertiesPreserveFormattingOnTextExtraction);
        }// query params
        
        if ($propertiesDetectLinesInsteadOfParagraphs !== null) {
            $queryParams['properties.detectLinesInsteadOfParagraphs'] = $this->apiClient->getSerializer()->toQueryValue($propertiesDetectLinesInsteadOfParagraphs);
        }// query params
        
        if ($propertiesTrimSpaces !== null) {
            $queryParams['properties.trimSpaces'] = $this->apiClient->getSerializer()->toQueryValue($propertiesTrimSpaces);
        }// query params
        
        if ($propertiesExtractColumnByColumn !== null) {
            $queryParams['properties.extractColumnByColumn'] = $this->apiClient->getSerializer()->toQueryValue($propertiesExtractColumnByColumn);
        }// query params
        
        if ($propertiesDetectNewColumnBySpacesRatio !== null) {
            $queryParams['properties.detectNewColumnBySpacesRatio'] = $this->apiClient->getSerializer()->toQueryValue($propertiesDetectNewColumnBySpacesRatio);
        }// query params
        
        if ($propertiesOcrMode !== null) {
            $queryParams['properties.ocrMode'] = $this->apiClient->getSerializer()->toQueryValue($propertiesOcrMode);
        }// query params
        
        if ($propertiesLineGroupingMode !== null) {
            $queryParams['properties.lineGroupingMode'] = $this->apiClient->getSerializer()->toQueryValue($propertiesLineGroupingMode);
        }// query params
        
        if ($propertiesColumnDetectionMode !== null) {
            $queryParams['properties.columnDetectionMode'] = $this->apiClient->getSerializer()->toQueryValue($propertiesColumnDetectionMode);
        }// query params
        
        if ($propertiesOcrCacheMode !== null) {
            $queryParams['properties.ocrCacheMode'] = $this->apiClient->getSerializer()->toQueryValue($propertiesOcrCacheMode);
        }// query params
        
        if ($propertiesOcrLanguage !== null) {
            $queryParams['properties.ocrLanguage'] = $this->apiClient->getSerializer()->toQueryValue($propertiesOcrLanguage);
        }// query params
        
        if ($propertiesOcrResolution !== null) {
            $queryParams['properties.ocrResolution'] = $this->apiClient->getSerializer()->toQueryValue($propertiesOcrResolution);
        }// query params
        
        if ($propertiesTextEncodingCodePage !== null) {
            $queryParams['properties.textEncodingCodePage'] = $this->apiClient->getSerializer()->toQueryValue($propertiesTextEncodingCodePage);
        }// query params
        
        if ($propertiesConsiderFontNames !== null) {
            $queryParams['properties.considerFontNames'] = $this->apiClient->getSerializer()->toQueryValue($propertiesConsiderFontNames);
        }// query params
        
        if ($propertiesConsiderFontSizes !== null) {
            $queryParams['properties.considerFontSizes'] = $this->apiClient->getSerializer()->toQueryValue($propertiesConsiderFontSizes);
        }// query params
        
        if ($propertiesConsiderFontColors !== null) {
            $queryParams['properties.considerFontColors'] = $this->apiClient->getSerializer()->toQueryValue($propertiesConsiderFontColors);
        }// query params
        
        if ($propertiesConsiderVerticalBorders !== null) {
            $queryParams['properties.considerVerticalBorders'] = $this->apiClient->getSerializer()->toQueryValue($propertiesConsiderVerticalBorders);
        }// query params
        
        if ($propertiesPassword !== null) {
            $queryParams['properties.password'] = $this->apiClient->getSerializer()->toQueryValue($propertiesPassword);
        }// query params
        
        if ($propertiesCheckPermissions !== null) {
            $queryParams['properties.checkPermissions'] = $this->apiClient->getSerializer()->toQueryValue($propertiesCheckPermissions);
        }// query params
        
        if ($propertiesExtractionAreaUsageMode !== null) {
            $queryParams['properties.extractionAreaUsageMode'] = $this->apiClient->getSerializer()->toQueryValue($propertiesExtractionAreaUsageMode);
        }// query params
        
        if ($outputType !== null) {
            $queryParams['outputType'] = $this->apiClient->getSerializer()->toQueryValue($outputType);
        }// query params
        
        if ($input !== null) {
            $queryParams['input'] = $this->apiClient->getSerializer()->toQueryValue($input);
        }// query params
        
        if ($inputType !== null) {
            $queryParams['inputType'] = $this->apiClient->getSerializer()->toQueryValue($inputType);
        }
        
        
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        
  
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath, 'GET',
                $queryParams, $httpBody,
                $headerParams, 'string'
            );
            
            if (!$response) {
                return array(null, $statusCode, $httpHeader);
            }

            return array(\Bytescout\Client\ObjectSerializer::deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader);
            
        } catch (ApiException $e) {
            switch ($e->getCode()) { 
            case 200:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 400:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 401:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 403:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 500:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\ExceptionResponse', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            }
  
            throw $e;
        }
    }
    
    /**
     * pDFExtractorXMLExtractorFile
     *
     * Convert PDF document to XML
     *
     * @param \Bytescout\Client\Model\XMLExtractorRequestVm $data  (required)
     * @param string $apikey User&#39;s ApiKey (optional)
     * @return string
     * @throws \Bytescout\Client\ApiException on non-2xx response
     */
    public function pDFExtractorXMLExtractorFile($data, $apikey = null)
    {
        list($response, $statusCode, $httpHeader) = $this->pDFExtractorXMLExtractorFileWithHttpInfo ($data, $apikey);
        return $response; 
    }


    /**
     * pDFExtractorXMLExtractorFileWithHttpInfo
     *
     * Convert PDF document to XML
     *
     * @param \Bytescout\Client\Model\XMLExtractorRequestVm $data  (required)
     * @param string $apikey User&#39;s ApiKey (optional)
     * @return Array of string, HTTP status code, HTTP response headers (array of strings)
     * @throws \Bytescout\Client\ApiException on non-2xx response
     */
    public function pDFExtractorXMLExtractorFileWithHttpInfo($data, $apikey = null)
    {
        
        // verify the required parameter 'data' is set
        if ($data === null) {
            throw new \InvalidArgumentException('Missing the required parameter $data when calling pDFExtractorXMLExtractorFile');
        }
  
        // parse inputs
        $resourcePath = "/api/v1/pdfextractor/xmlextractor/extract";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = ApiClient::selectHeaderAccept(array('application/json', 'text/json', 'application/xml', 'text/xml'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = ApiClient::selectHeaderContentType(array('application/json','text/json','application/xml','text/xml'));
  
        // query params
        
        if ($apikey !== null) {
            $queryParams['apikey'] = $this->apiClient->getSerializer()->toQueryValue($apikey);
        }
        
        
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // body params
        $_tempBody = null;
        if (isset($data)) {
            $_tempBody = $data;
        }
  
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath, 'POST',
                $queryParams, $httpBody,
                $headerParams, 'string'
            );
            
            if (!$response) {
                return array(null, $statusCode, $httpHeader);
            }

            return array(\Bytescout\Client\ObjectSerializer::deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader);
            
        } catch (ApiException $e) {
            switch ($e->getCode()) { 
            case 200:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 400:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 401:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 403:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 500:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\ExceptionResponse', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            }
  
            throw $e;
        }
    }
    
    /**
     * pDFExtractorXMLExtractorLink
     *
     * Convert PDF document to CSV
     *
     * @param string $apikey User&#39;s ApiKey (optional)
     * @param int $propertiesStartPageIndex Index of page (zero-based) of PDF file from which data will be extracted.\r\n            Default value: all pages (optional)
     * @param int $propertiesEndPageIndex Index of a page (zero-based) on which extracting of data will be finished.\r\n            Default value: all pages (optional)
     * @param double $propertiesXCoordinateToleranceFactor Default value: 20 (optional)
     * @param double $propertiesYCoordinateToleranceFactor Default value: 30 (optional)
     * @param int $propertiesTableXMinIntersectionRequiredInPercents Default value: 49 (optional)
     * @param int $propertiesTableYMinIntersectionRequiredInPercents Default value: 50 (optional)
     * @param bool $propertiesRtlTextAutoDetectionEnabled Default value: False (optional)
     * @param bool $propertiesExtractInvisibleText Default value: True (optional)
     * @param bool $propertiesExtractShadowLikeText Default value: True (optional)
     * @param bool $propertiesUnwrap Default value: False (optional)
     * @param bool $propertiesRemoveHyphenation Default value: True (optional)
     * @param bool $propertiesAutoAlignColumnsToHeader Default value: True (optional)
     * @param bool $propertiesPreserveFormattingOnTextExtraction Value indicating whether to preserve the text formatting on the extraction.\r\n            Default value: True (optional)
     * @param bool $propertiesDetectLinesInsteadOfParagraphs Default value: True (optional)
     * @param bool $propertiesTrimSpaces Default value: True (optional)
     * @param bool $propertiesExtractColumnByColumn Default value: False (optional)
     * @param float $propertiesDetectNewColumnBySpacesRatio Space ratio between words.\r\n            Default value: 1 (optional)
     * @param string $propertiesOcrMode Default value: Off (optional)
     * @param string $propertiesLineGroupingMode Default value: None (optional)
     * @param string $propertiesColumnDetectionMode Default value: ContentGroupsAndBorders (optional)
     * @param string $propertiesOcrCacheMode Recognize text on embedded images using Optical Character Recognition (OCR). Set the language using OCRLanguage property.\r\n            Default value: Off (optional)
     * @param string $propertiesOcrLanguage Default value: eng (optional)
     * @param float $propertiesOcrResolution Default value: 300 (optional)
     * @param int $propertiesTextEncodingCodePage Default value: 1252 (optional)
     * @param bool $propertiesConsiderFontNames Default value: False (optional)
     * @param bool $propertiesConsiderFontSizes Default value: False (optional)
     * @param bool $propertiesConsiderFontColors Default value: False (optional)
     * @param bool $propertiesConsiderVerticalBorders Default value: True (optional)
     * @param string $propertiesPassword Default value: (optional)
     * @param bool $propertiesCheckPermissions Default value: True (optional)
     * @param string $propertiesExtractionAreaUsageMode Default value: UseAllIntersectingObjects (optional)
     * @param string $outputType Type in which you want to get result of extracting (optional). Default value: Content. \r\n            IMPORTANT: \r\n            Link type generates public unique link to download, file is removed after default StorageTime(see File API). \r\n            LinkPrivate generates private unique link which should NOT be shared as it can be accessed with your api key only! (optional)
     * @param string $input Input Data (optional)
     * @param string $inputType Type of Input Data (optional)
     * @return string
     * @throws \Bytescout\Client\ApiException on non-2xx response
     */
    public function pDFExtractorXMLExtractorLink($apikey = null, $propertiesStartPageIndex = null, $propertiesEndPageIndex = null, $propertiesXCoordinateToleranceFactor = null, $propertiesYCoordinateToleranceFactor = null, $propertiesTableXMinIntersectionRequiredInPercents = null, $propertiesTableYMinIntersectionRequiredInPercents = null, $propertiesRtlTextAutoDetectionEnabled = null, $propertiesExtractInvisibleText = null, $propertiesExtractShadowLikeText = null, $propertiesUnwrap = null, $propertiesRemoveHyphenation = null, $propertiesAutoAlignColumnsToHeader = null, $propertiesPreserveFormattingOnTextExtraction = null, $propertiesDetectLinesInsteadOfParagraphs = null, $propertiesTrimSpaces = null, $propertiesExtractColumnByColumn = null, $propertiesDetectNewColumnBySpacesRatio = null, $propertiesOcrMode = null, $propertiesLineGroupingMode = null, $propertiesColumnDetectionMode = null, $propertiesOcrCacheMode = null, $propertiesOcrLanguage = null, $propertiesOcrResolution = null, $propertiesTextEncodingCodePage = null, $propertiesConsiderFontNames = null, $propertiesConsiderFontSizes = null, $propertiesConsiderFontColors = null, $propertiesConsiderVerticalBorders = null, $propertiesPassword = null, $propertiesCheckPermissions = null, $propertiesExtractionAreaUsageMode = null, $outputType = null, $input = null, $inputType = null)
    {
        list($response, $statusCode, $httpHeader) = $this->pDFExtractorXMLExtractorLinkWithHttpInfo ($apikey, $propertiesStartPageIndex, $propertiesEndPageIndex, $propertiesXCoordinateToleranceFactor, $propertiesYCoordinateToleranceFactor, $propertiesTableXMinIntersectionRequiredInPercents, $propertiesTableYMinIntersectionRequiredInPercents, $propertiesRtlTextAutoDetectionEnabled, $propertiesExtractInvisibleText, $propertiesExtractShadowLikeText, $propertiesUnwrap, $propertiesRemoveHyphenation, $propertiesAutoAlignColumnsToHeader, $propertiesPreserveFormattingOnTextExtraction, $propertiesDetectLinesInsteadOfParagraphs, $propertiesTrimSpaces, $propertiesExtractColumnByColumn, $propertiesDetectNewColumnBySpacesRatio, $propertiesOcrMode, $propertiesLineGroupingMode, $propertiesColumnDetectionMode, $propertiesOcrCacheMode, $propertiesOcrLanguage, $propertiesOcrResolution, $propertiesTextEncodingCodePage, $propertiesConsiderFontNames, $propertiesConsiderFontSizes, $propertiesConsiderFontColors, $propertiesConsiderVerticalBorders, $propertiesPassword, $propertiesCheckPermissions, $propertiesExtractionAreaUsageMode, $outputType, $input, $inputType);
        return $response; 
    }


    /**
     * pDFExtractorXMLExtractorLinkWithHttpInfo
     *
     * Convert PDF document to CSV
     *
     * @param string $apikey User&#39;s ApiKey (optional)
     * @param int $propertiesStartPageIndex Index of page (zero-based) of PDF file from which data will be extracted.\r\n            Default value: all pages (optional)
     * @param int $propertiesEndPageIndex Index of a page (zero-based) on which extracting of data will be finished.\r\n            Default value: all pages (optional)
     * @param double $propertiesXCoordinateToleranceFactor Default value: 20 (optional)
     * @param double $propertiesYCoordinateToleranceFactor Default value: 30 (optional)
     * @param int $propertiesTableXMinIntersectionRequiredInPercents Default value: 49 (optional)
     * @param int $propertiesTableYMinIntersectionRequiredInPercents Default value: 50 (optional)
     * @param bool $propertiesRtlTextAutoDetectionEnabled Default value: False (optional)
     * @param bool $propertiesExtractInvisibleText Default value: True (optional)
     * @param bool $propertiesExtractShadowLikeText Default value: True (optional)
     * @param bool $propertiesUnwrap Default value: False (optional)
     * @param bool $propertiesRemoveHyphenation Default value: True (optional)
     * @param bool $propertiesAutoAlignColumnsToHeader Default value: True (optional)
     * @param bool $propertiesPreserveFormattingOnTextExtraction Value indicating whether to preserve the text formatting on the extraction.\r\n            Default value: True (optional)
     * @param bool $propertiesDetectLinesInsteadOfParagraphs Default value: True (optional)
     * @param bool $propertiesTrimSpaces Default value: True (optional)
     * @param bool $propertiesExtractColumnByColumn Default value: False (optional)
     * @param float $propertiesDetectNewColumnBySpacesRatio Space ratio between words.\r\n            Default value: 1 (optional)
     * @param string $propertiesOcrMode Default value: Off (optional)
     * @param string $propertiesLineGroupingMode Default value: None (optional)
     * @param string $propertiesColumnDetectionMode Default value: ContentGroupsAndBorders (optional)
     * @param string $propertiesOcrCacheMode Recognize text on embedded images using Optical Character Recognition (OCR). Set the language using OCRLanguage property.\r\n            Default value: Off (optional)
     * @param string $propertiesOcrLanguage Default value: eng (optional)
     * @param float $propertiesOcrResolution Default value: 300 (optional)
     * @param int $propertiesTextEncodingCodePage Default value: 1252 (optional)
     * @param bool $propertiesConsiderFontNames Default value: False (optional)
     * @param bool $propertiesConsiderFontSizes Default value: False (optional)
     * @param bool $propertiesConsiderFontColors Default value: False (optional)
     * @param bool $propertiesConsiderVerticalBorders Default value: True (optional)
     * @param string $propertiesPassword Default value: (optional)
     * @param bool $propertiesCheckPermissions Default value: True (optional)
     * @param string $propertiesExtractionAreaUsageMode Default value: UseAllIntersectingObjects (optional)
     * @param string $outputType Type in which you want to get result of extracting (optional). Default value: Content. \r\n            IMPORTANT: \r\n            Link type generates public unique link to download, file is removed after default StorageTime(see File API). \r\n            LinkPrivate generates private unique link which should NOT be shared as it can be accessed with your api key only! (optional)
     * @param string $input Input Data (optional)
     * @param string $inputType Type of Input Data (optional)
     * @return Array of string, HTTP status code, HTTP response headers (array of strings)
     * @throws \Bytescout\Client\ApiException on non-2xx response
     */
    public function pDFExtractorXMLExtractorLinkWithHttpInfo($apikey = null, $propertiesStartPageIndex = null, $propertiesEndPageIndex = null, $propertiesXCoordinateToleranceFactor = null, $propertiesYCoordinateToleranceFactor = null, $propertiesTableXMinIntersectionRequiredInPercents = null, $propertiesTableYMinIntersectionRequiredInPercents = null, $propertiesRtlTextAutoDetectionEnabled = null, $propertiesExtractInvisibleText = null, $propertiesExtractShadowLikeText = null, $propertiesUnwrap = null, $propertiesRemoveHyphenation = null, $propertiesAutoAlignColumnsToHeader = null, $propertiesPreserveFormattingOnTextExtraction = null, $propertiesDetectLinesInsteadOfParagraphs = null, $propertiesTrimSpaces = null, $propertiesExtractColumnByColumn = null, $propertiesDetectNewColumnBySpacesRatio = null, $propertiesOcrMode = null, $propertiesLineGroupingMode = null, $propertiesColumnDetectionMode = null, $propertiesOcrCacheMode = null, $propertiesOcrLanguage = null, $propertiesOcrResolution = null, $propertiesTextEncodingCodePage = null, $propertiesConsiderFontNames = null, $propertiesConsiderFontSizes = null, $propertiesConsiderFontColors = null, $propertiesConsiderVerticalBorders = null, $propertiesPassword = null, $propertiesCheckPermissions = null, $propertiesExtractionAreaUsageMode = null, $outputType = null, $input = null, $inputType = null)
    {
        
  
        // parse inputs
        $resourcePath = "/api/v1/pdfextractor/xmlextractor/extract";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = ApiClient::selectHeaderAccept(array('application/json', 'text/json', 'application/xml', 'text/xml'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = ApiClient::selectHeaderContentType(array());
  
        // query params
        
        if ($apikey !== null) {
            $queryParams['apikey'] = $this->apiClient->getSerializer()->toQueryValue($apikey);
        }// query params
        
        if ($propertiesStartPageIndex !== null) {
            $queryParams['properties.startPageIndex'] = $this->apiClient->getSerializer()->toQueryValue($propertiesStartPageIndex);
        }// query params
        
        if ($propertiesEndPageIndex !== null) {
            $queryParams['properties.endPageIndex'] = $this->apiClient->getSerializer()->toQueryValue($propertiesEndPageIndex);
        }// query params
        
        if ($propertiesXCoordinateToleranceFactor !== null) {
            $queryParams['properties.xCoordinateToleranceFactor'] = $this->apiClient->getSerializer()->toQueryValue($propertiesXCoordinateToleranceFactor);
        }// query params
        
        if ($propertiesYCoordinateToleranceFactor !== null) {
            $queryParams['properties.yCoordinateToleranceFactor'] = $this->apiClient->getSerializer()->toQueryValue($propertiesYCoordinateToleranceFactor);
        }// query params
        
        if ($propertiesTableXMinIntersectionRequiredInPercents !== null) {
            $queryParams['properties.tableXMinIntersectionRequiredInPercents'] = $this->apiClient->getSerializer()->toQueryValue($propertiesTableXMinIntersectionRequiredInPercents);
        }// query params
        
        if ($propertiesTableYMinIntersectionRequiredInPercents !== null) {
            $queryParams['properties.tableYMinIntersectionRequiredInPercents'] = $this->apiClient->getSerializer()->toQueryValue($propertiesTableYMinIntersectionRequiredInPercents);
        }// query params
        
        if ($propertiesRtlTextAutoDetectionEnabled !== null) {
            $queryParams['properties.rtlTextAutoDetectionEnabled'] = $this->apiClient->getSerializer()->toQueryValue($propertiesRtlTextAutoDetectionEnabled);
        }// query params
        
        if ($propertiesExtractInvisibleText !== null) {
            $queryParams['properties.extractInvisibleText'] = $this->apiClient->getSerializer()->toQueryValue($propertiesExtractInvisibleText);
        }// query params
        
        if ($propertiesExtractShadowLikeText !== null) {
            $queryParams['properties.extractShadowLikeText'] = $this->apiClient->getSerializer()->toQueryValue($propertiesExtractShadowLikeText);
        }// query params
        
        if ($propertiesUnwrap !== null) {
            $queryParams['properties.unwrap'] = $this->apiClient->getSerializer()->toQueryValue($propertiesUnwrap);
        }// query params
        
        if ($propertiesRemoveHyphenation !== null) {
            $queryParams['properties.removeHyphenation'] = $this->apiClient->getSerializer()->toQueryValue($propertiesRemoveHyphenation);
        }// query params
        
        if ($propertiesAutoAlignColumnsToHeader !== null) {
            $queryParams['properties.autoAlignColumnsToHeader'] = $this->apiClient->getSerializer()->toQueryValue($propertiesAutoAlignColumnsToHeader);
        }// query params
        
        if ($propertiesPreserveFormattingOnTextExtraction !== null) {
            $queryParams['properties.preserveFormattingOnTextExtraction'] = $this->apiClient->getSerializer()->toQueryValue($propertiesPreserveFormattingOnTextExtraction);
        }// query params
        
        if ($propertiesDetectLinesInsteadOfParagraphs !== null) {
            $queryParams['properties.detectLinesInsteadOfParagraphs'] = $this->apiClient->getSerializer()->toQueryValue($propertiesDetectLinesInsteadOfParagraphs);
        }// query params
        
        if ($propertiesTrimSpaces !== null) {
            $queryParams['properties.trimSpaces'] = $this->apiClient->getSerializer()->toQueryValue($propertiesTrimSpaces);
        }// query params
        
        if ($propertiesExtractColumnByColumn !== null) {
            $queryParams['properties.extractColumnByColumn'] = $this->apiClient->getSerializer()->toQueryValue($propertiesExtractColumnByColumn);
        }// query params
        
        if ($propertiesDetectNewColumnBySpacesRatio !== null) {
            $queryParams['properties.detectNewColumnBySpacesRatio'] = $this->apiClient->getSerializer()->toQueryValue($propertiesDetectNewColumnBySpacesRatio);
        }// query params
        
        if ($propertiesOcrMode !== null) {
            $queryParams['properties.ocrMode'] = $this->apiClient->getSerializer()->toQueryValue($propertiesOcrMode);
        }// query params
        
        if ($propertiesLineGroupingMode !== null) {
            $queryParams['properties.lineGroupingMode'] = $this->apiClient->getSerializer()->toQueryValue($propertiesLineGroupingMode);
        }// query params
        
        if ($propertiesColumnDetectionMode !== null) {
            $queryParams['properties.columnDetectionMode'] = $this->apiClient->getSerializer()->toQueryValue($propertiesColumnDetectionMode);
        }// query params
        
        if ($propertiesOcrCacheMode !== null) {
            $queryParams['properties.ocrCacheMode'] = $this->apiClient->getSerializer()->toQueryValue($propertiesOcrCacheMode);
        }// query params
        
        if ($propertiesOcrLanguage !== null) {
            $queryParams['properties.ocrLanguage'] = $this->apiClient->getSerializer()->toQueryValue($propertiesOcrLanguage);
        }// query params
        
        if ($propertiesOcrResolution !== null) {
            $queryParams['properties.ocrResolution'] = $this->apiClient->getSerializer()->toQueryValue($propertiesOcrResolution);
        }// query params
        
        if ($propertiesTextEncodingCodePage !== null) {
            $queryParams['properties.textEncodingCodePage'] = $this->apiClient->getSerializer()->toQueryValue($propertiesTextEncodingCodePage);
        }// query params
        
        if ($propertiesConsiderFontNames !== null) {
            $queryParams['properties.considerFontNames'] = $this->apiClient->getSerializer()->toQueryValue($propertiesConsiderFontNames);
        }// query params
        
        if ($propertiesConsiderFontSizes !== null) {
            $queryParams['properties.considerFontSizes'] = $this->apiClient->getSerializer()->toQueryValue($propertiesConsiderFontSizes);
        }// query params
        
        if ($propertiesConsiderFontColors !== null) {
            $queryParams['properties.considerFontColors'] = $this->apiClient->getSerializer()->toQueryValue($propertiesConsiderFontColors);
        }// query params
        
        if ($propertiesConsiderVerticalBorders !== null) {
            $queryParams['properties.considerVerticalBorders'] = $this->apiClient->getSerializer()->toQueryValue($propertiesConsiderVerticalBorders);
        }// query params
        
        if ($propertiesPassword !== null) {
            $queryParams['properties.password'] = $this->apiClient->getSerializer()->toQueryValue($propertiesPassword);
        }// query params
        
        if ($propertiesCheckPermissions !== null) {
            $queryParams['properties.checkPermissions'] = $this->apiClient->getSerializer()->toQueryValue($propertiesCheckPermissions);
        }// query params
        
        if ($propertiesExtractionAreaUsageMode !== null) {
            $queryParams['properties.extractionAreaUsageMode'] = $this->apiClient->getSerializer()->toQueryValue($propertiesExtractionAreaUsageMode);
        }// query params
        
        if ($outputType !== null) {
            $queryParams['outputType'] = $this->apiClient->getSerializer()->toQueryValue($outputType);
        }// query params
        
        if ($input !== null) {
            $queryParams['input'] = $this->apiClient->getSerializer()->toQueryValue($input);
        }// query params
        
        if ($inputType !== null) {
            $queryParams['inputType'] = $this->apiClient->getSerializer()->toQueryValue($inputType);
        }
        
        
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        
  
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath, 'GET',
                $queryParams, $httpBody,
                $headerParams, 'string'
            );
            
            if (!$response) {
                return array(null, $statusCode, $httpHeader);
            }

            return array(\Bytescout\Client\ObjectSerializer::deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader);
            
        } catch (ApiException $e) {
            switch ($e->getCode()) { 
            case 200:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 400:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 401:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 403:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\BadRequestModel', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            case 500:
                $data = \Bytescout\Client\ObjectSerializer::deserialize($e->getResponseBody(), '\Bytescout\Client\Model\ExceptionResponse', $e->getResponseHeaders());
                $e->setResponseObject($data);
                break;
            }
  
            throw $e;
        }
    }
    
}
